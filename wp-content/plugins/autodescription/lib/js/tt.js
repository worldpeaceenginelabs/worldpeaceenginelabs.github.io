'use strict';window.tsfTT=function(){const _ttBase='tsf-tooltip';const ttNames={base:_ttBase,item:`${_ttBase}-item`,wrap:`${_ttBase}-wrap`,text:`${_ttBase}-text`,textWrap:`${_ttBase}-text-wrap`,boundary:`${_ttBase}-boundary`,arrow:`${_ttBase}-arrow`,}
const ttSelectors=Object.fromEntries(Object.entries(ttNames).map(([i,v])=>[i,`.${v}`]));const _activeToolTipHandles={updateDesc:event=>{if(!event.target.classList.contains(ttNames.item))return;let tooltipText=event.target.querySelector(ttSelectors.text);if(tooltipText instanceof Element){tooltipText.innerHTML=event.target.dataset.desc;event.target.dispatchEvent(new Event('mousemove'));}},pointerEnter:async event=>{let desc=event.target.dataset.desc||event.target.title||'';if(desc&&!event.target.getElementsByClassName(ttNames.base).length){event.target.dataset.desc=desc;event.target.removeAttribute('title');return await doTooltip(event,event.target,desc);}
return false;},pointerMove:event=>{_pointer.currPos.x=event.pageX||NaN;_pointer.lastMoveEvent=event;},pointerLeave:event=>{removeTooltip(event.target);_events(event.target).unset();if(!event.relatedTarget?.classList?.contains(ttNames.item))
_cancelArrowAnimation();},}
const _events=target=>{const commonEvents={mousemove:_activeToolTipHandles.pointerMove,mouseleave:_activeToolTipHandles.pointerLeave,mouseout:_activeToolTipHandles.pointerLeave,blur:_activeToolTipHandles.pointerLeave,};return{set:()=>{for(const[event,callBack]of Object.entries(commonEvents)){target.addEventListener(event,callBack);}
target.addEventListener('tsf-tooltip-update',_activeToolTipHandles.updateDesc);},unset:()=>{for(const[event,callBack]of Object.entries(commonEvents)){target.removeEventListener(event,callBack);}},};}
const _activeTooltipElements={tooltip:void 0,arrow:void 0,wrap:void 0,reset:()=>{_activeTooltipElements.tooltip=_activeTooltipElements.arrow=_activeTooltipElements.wrap=void 0;}};const _pointer={lastPos:{x:void 0},currPos:{x:void 0},lastMoveEvent:void 0,reset:()=>{_pointer.lastMoveEvent=void 0;_pointer.currPos={x:void 0};_pointer.lastPos={x:void 0};}}
const{_requestArrowAnimation,_cancelArrowAnimation,_requestArrowAnimationOnce,}=(()=>{let _pointerAnimationId=void 0;const _requestArrowAnimation=()=>{_pointerAnimationId=requestAnimationFrame(animate);}
const _cancelArrowAnimation=()=>{cancelAnimationFrame(_pointerAnimationId);_pointer.lastMoveEvent=void 0;_activeTooltipElements.reset();_pointer.reset();}
const _requestArrowAnimationOnce=()=>{animate();_cancelArrowAnimation();}
const animate=()=>{let isMouseEvent=![_pointer.currPos.x].includes(NaN);if(isMouseEvent){if(_pointer.currPos.x===_pointer.lastPos.x){_requestArrowAnimation();return;}}
_pointer.lastPos.x=_pointer.currPos.x;const event=_pointer.lastMoveEvent;let tooltip=_activeTooltipElements.tooltip||(event&&event.target.querySelector(ttSelectors.base));if(!tooltip){_requestArrowAnimation();return;}
_activeTooltipElements.tooltip||=tooltip;_activeTooltipElements.arrow||=tooltip.querySelector(ttSelectors.arrow);_activeTooltipElements.wrap||=event.target.closest(ttSelectors.wrap)||event.target.parentNode;let pagex=_pointer.currPos.x,arrowBoundary=7,arrowWidth=16;if('focus'===event.type){pagex=event.target.getBoundingClientRect().left+(event.target.offsetWidth/2);}else if(isNaN(pagex)){pagex=_activeTooltipElements.tooltip.dataset.lastPagex||event.target.getBoundingClientRect().left;}
_activeTooltipElements.tooltip.dataset.lastPagex=pagex;let mousex=pagex-_activeTooltipElements.wrap.getBoundingClientRect().left-(arrowWidth/2),textWrap=_activeTooltipElements.tooltip.querySelector(ttSelectors.textWrap),textWrapWidth=textWrap.offsetWidth,adjust=_activeTooltipElements.tooltip.dataset.adjust,boundaryRight=textWrapWidth-arrowWidth-arrowBoundary;adjust=parseInt(adjust,10);adjust=isNaN(adjust)?0:Math.round(adjust);if(adjust){mousex=mousex-adjust;if(boundaryRight+adjust>_activeTooltipElements.wrap.offsetWidth){let innerText=textWrap.querySelector(ttSelectors.text),textWidth=innerText.offsetWidth;boundaryRight=textWidth-arrowWidth-arrowBoundary;}}
if(mousex<=arrowBoundary){_activeTooltipElements.arrow.style.left=`${arrowBoundary}px`;}else if(mousex>=boundaryRight){_activeTooltipElements.arrow.style.left=`${boundaryRight}px`;}else{_activeTooltipElements.arrow.style.left=`${mousex}px`;}
if(isMouseEvent){_requestArrowAnimation();}else{_pointerAnimationId&&_cancelArrowAnimation();}}
return{_requestArrowAnimation,_cancelArrowAnimation,_requestArrowAnimationOnce,};})();const _clickLocker=element=>{return{lock:()=>{element.dataset.preventedClick=1;if(element instanceof HTMLLabelElement&&element.htmlFor){let input=document.getElementById(element.htmlFor);if(input)input.dataset.preventedClick=1;}
if(element instanceof HTMLInputElement&&element.id){document.querySelectorAll(`label[for="${element.id}"]`).forEach(label=>{label.dataset.preventedClick=1;});}},release:()=>{if(!(element instanceof Element))return;delete element.dataset.preventedClick;if(element instanceof HTMLLabelElement&&element.htmlFor){let input=document.getElementById(element.htmlFor);if(input)delete input.dataset.preventedClick;}
if(element instanceof HTMLInputElement&&element.id){document.querySelectorAll(`label[for="${element.id}"]`).forEach(la=>{delete la.dataset.preventedClick;});}},isLocked:()=>element instanceof Element&&!!+element.dataset.preventedClick,}}
const _initToolTips=()=>{let passiveSupported=false,captureSupported=false;try{(()=>{const options={get passive(){passiveSupported=true;return false;},get capture(){captureSupported=true;return false;},};window.addEventListener('tsf-tt-test-passive',null,options);window.removeEventListener('tsf-tt-test-passive',null,options);})();}catch(e){passiveSupported=false;captureSupported=false;}
const loadToolTip=async(event)=>{if(event.target.dataset.hasTooltip)return;let isTouch=false;switch(event.type){case 'mouseenter':break;case 'pointerdown':case 'touchstart':isTouch=true;break;case 'focus':default:break;}
if(!isTouch)
_clickLocker(event.target).lock();_cancelArrowAnimation();if(!(await _activeToolTipHandles.pointerEnter(event)))return;_activeToolTipHandles.pointerMove(event);if(isTouch){_requestArrowAnimationOnce();}else{_requestArrowAnimation();}
_events(event.target).set();}
const preventTooltipHandleClick=event=>{if(_clickLocker(event.target).isLocked())return;event.preventDefault();setTimeout(()=>_clickLocker(event.target).lock());}
let instigatingTooltip=false;const handleToolTip=event=>{if(instigatingTooltip)return;instigatingTooltip=true;if(event.target.classList.contains(ttNames.item))
loadToolTip(event);event.stopPropagation();instigatingTooltip=false;}
let initTimeout=void 0;const options=passiveSupported&&captureSupported?{capture:true,passive:true}:true;const init=()=>{let wraps=document.querySelectorAll(ttSelectors.wrap),actions='mouseenter pointerdown touchstart focus'.split(' ');for(let i=0;i<wraps.length;i++){actions.forEach(e=>{wraps[i].addEventListener(e,handleToolTip,options);});wraps[i].addEventListener('click',preventTooltipHandleClick,captureSupported?{capture:false}:false);}}
window.addEventListener('tsf-tooltip-reset',init);triggerReset();addBoundary('#wpwrap');}
const _renderTooltip=(event,element,desc)=>{element.dataset.hasTooltip=1;let tooltip=document.createElement('div');tooltip.classList.add(ttNames.base);tooltip.insertAdjacentHTML('afterbegin',`<span class=${ttNames.textWrap}><span class=${ttNames.text}>${desc}</span></span><div class=${ttNames.arrow} style=will-change:left></div>`);element.prepend(tooltip);let boundary=element.closest(ttSelectors.boundary)||document.body,boundaryRect=boundary.getBoundingClientRect(),boundaryTop=boundaryRect.top-(boundary.scrollTop||0),boundaryWidth=boundary.offsetWidth,maxWidth=250,appeal=12;let hoverItemWrap=element.closest(ttSelectors.wrap)||element.parentElement,hoverItemWrapRect=hoverItemWrap.getBoundingClientRect(),textWrap=tooltip.querySelector(ttSelectors.textWrap),textWrapRect=textWrap.getBoundingClientRect(),hoverItemWrapWidth=hoverItemWrapRect.width;if(textWrapRect.width>maxWidth&&hoverItemWrapWidth<maxWidth&&hoverItemWrapWidth>150){textWrap.style.flexBasis=`${hoverItemWrapWidth}px`;}
if(textWrap.offsetWidth>(boundaryWidth-(appeal/2))){textWrap.style.flexBasis=`${Math.min(maxWidth,boundaryWidth-appeal)}px`;appeal/=2;}else if(textWrapRect.width>maxWidth){textWrap.style.flexBasis=`${maxWidth}px`;}
let boundaryLeft=boundaryRect.left-(boundary.scrollLeft||0),boundaryRight=boundaryLeft+boundaryWidth;let textWrapWidth=textWrap.offsetWidth,textBorderLeft=textWrapRect.left,textBorderRight=textBorderLeft+textWrapWidth;let horIndent=0;if(textBorderLeft<boundaryLeft){horIndent=boundaryLeft-textBorderLeft+appeal;}else if(textBorderRight>boundaryRight){horIndent=boundaryRight-textBorderLeft-textWrapWidth-appeal;}else if(hoverItemWrapWidth<42){horIndent=(-hoverItemWrapWidth/2)-appeal;}else if(hoverItemWrapWidth>textWrapWidth){let pagex=event&&event.pageX||NaN;if(event&&'focus'===event.type){horIndent=(hoverItemWrapWidth/2)-(textWrapWidth/2);}else if(isNaN(pagex)){horIndent=-appeal;}else{horIndent=pagex-hoverItemWrapRect.left-(textWrapWidth/2);}
let appealLeft=-appeal,appealRight=hoverItemWrapWidth-textWrapWidth+appeal;if(horIndent<appealLeft){horIndent=appealLeft;}
if(horIndent>appealRight){horIndent=appealRight;}}
if((horIndent+textBorderLeft)<(boundaryLeft+appeal)){let _adjustLeft=(horIndent+textBorderLeft)-(boundaryLeft+(appeal/2));horIndent=horIndent-_adjustLeft;}
if((horIndent+textBorderRight)>(boundaryRight+appeal)){let _adjustRight=(horIndent+textBorderRight)-(boundaryRight+(appeal/2));horIndent=horIndent-_adjustRight;}
if((horIndent+textBorderLeft)<boundaryLeft){horIndent=0;}
if(!event){let basis=parseInt(textWrap.style.flexBasis,10);if(horIndent<-basis){horIndent=-basis;}}
tooltip.style.left=`${horIndent}px`;tooltip.dataset.adjust=horIndent;let tooltipHeight=element.offsetHeight+8,tooltipTop=tooltip.getBoundingClientRect().top-tooltipHeight;if(boundaryTop>tooltipTop){tooltip.classList.add('tsf-tooltip-down');tooltip.style.top=`${tooltipHeight}px`;}else{tooltip.style.bottom=`${tooltipHeight}px`;}
return true;}
const doTooltip=(event,element,desc)=>{if(element?.[0])
element=element[0];for(const element of document.querySelectorAll(ttSelectors.base)){removeTooltip(element);_events(element).unset();}
if(!desc.length)return false;return _renderTooltip(event,element,desc);}
const addBoundary=element=>{element instanceof Element&&element.classList.add(ttNames.boundary)};const removeTooltip=element=>{if(element?.[0])
element=element[0];if(element instanceof HTMLElement){delete element.dataset.hasTooltip;_clickLocker(element).release();}
const toolTip=getTooltip(element);toolTip?.parentNode.removeChild(toolTip);}
const getTooltip=element=>{if(element?.[0])
element=element[0];return element?.classList.contains(ttNames.base)?element:element?.querySelector(ttSelectors.base);}
let _debounceTriggerReset=void 0;const triggerReset=()=>{clearTimeout(_debounceTriggerReset);_debounceTriggerReset=setTimeout(()=>window.dispatchEvent(new CustomEvent('tsf-tooltip-reset')),100);}
const triggerUpdate=element=>{if(!element||!(element instanceof Element))
element=document.querySelectorAll(ttSelectors.item);if(!element)return;const updateEvent=new CustomEvent('tsf-tooltip-update');if(element instanceof Element){element.dispatchEvent(updateEvent);}else if(element instanceof Nodelist){element.forEach(el=>el.dispatchEvent(updateEvent));}}
return Object.assign({load:()=>{document.body.addEventListener('tsf-ready',_initToolTips);}},{doTooltip,removeTooltip,getTooltip,addBoundary,triggerReset,triggerUpdate,});}();window.tsfTT.load();